// //! # SpiceFlow - Server - A Market Data Server

// use dotenv::dotenv;
// use server::actors::bc::BroadcastActor;
// use server::actors::ob::OrderBookActor;
// use server::actors::router::{DeribitMessageRouter, ParsedMessage};
// use server::actors::stream_config::StreamConfig;
// use server::actors::orch::Orchestrator;
// use tokio::sync::mpsc;

// const CHANNEL_BUFFER_SIZE: usize = 10;

// #[tokio::main]
// async fn main() {
//     // Load env
//     dotenv().ok();

//     // Initialise the logger
//     env_logger::Builder::from_env(env_logger::Env::default().default_filter_or("info"))
//         .format(|buf, record| {
//             use std::io::Write;
//             writeln!(
//                 buf,
//                 "{} [{}:{}] {} - {}",
//                 chrono::Local::now().format("%Y-%m-%d %H:%M:%S"),
//                 record.file().unwrap_or("unknown"),
//                 record.line().unwrap_or(0),
//                 record.level(),
//                 record.args()
//             )
//         })
//         .init();

// https://github.com/snapview/tokio-tungstenite/issues/353
// rustls::crypto::aws_lc_rs::default_provider()
//     .install_default()
//     .expect("Failed to install default TLS provider");

//     // Create ZeroMQ context
//     // Create ZeroMQ context and socket
//     let zmq_context = zmq::Context::new();
//     let zmq_socket = zmq_context
//         .socket(zmq::PUB)
//         .expect("Failed to create ZeroMQ socket");
//     zmq_socket
//         .bind("tcp://*:5555")
//         .expect("Failed to bind ZeroMQ socket");

//     // Prototype Orchestrator
//     let (tx, rx) = mpsc::channel(32);
//     let mut orchestrator = Orchestrator::new(rx);

//     // Create channels
//     // WS to Router
//     let (ws_router_sender, ws_router_receiver) = mpsc::channel::<String>(CHANNEL_BUFFER_SIZE);
//     // OrderBookActor to WebsocketActor to send resubscribes
//     // TODO responsibility to be shared between Router and OB in future release
//     let (ws_command_sender, ws_command_receiver) = mpsc::channel(CHANNEL_BUFFER_SIZE);
//     // OrderBookActor to BroadcastActor
//     let (broadcast, receiver) = mpsc::channel(CHANNEL_BUFFER_SIZE);
//     // Router to OrderBookActor
//     let (parsed_data_sender, parsed_data_receiver) =
//         mpsc::channel::<ParsedMessage>(CHANNEL_BUFFER_SIZE);

//     // Initialise config, this will be replaced and generated by StreamManager in later iters
//     let config = StreamConfig::current();

//     // Create Actors
//     let mut broadcast_actor = BroadcastActor::new(receiver, zmq_socket);
//     let mut order_book_actor = OrderBookActor::new(
//         "OrderBookActor",
//         &config,
//         parsed_data_receiver,
//         broadcast,
//         ws_command_sender,
//     );
//     let mut router_actor = DeribitMessageRouter::new(ws_router_receiver, parsed_data_sender);

//     orchestrator.spawn_websocket_actor(ws_router_sender, ws_command_receiver);

//     // Run the actors concurrently
//     tokio::join!(
//         broadcast_actor.run(),
//         order_book_actor.run(),
//         router_actor.run()
//     );
// }

// New Framework (In Development!)

use std::time::Duration;
use dotenv::dotenv;
use server::async_actors::common::RequestedFeed;
use server::async_actors::messages::DummyRequest;
use server::async_actors::orchestrator::Orchestrator;
use tokio;
use tokio::sync::mpsc;
use tokio::time;
use tracing::info;
use tracing_subscriber;

#[tokio::main]
async fn main() {
    
    dotenv().ok();

    rustls::crypto::aws_lc_rs::default_provider()
        .install_default()
        .expect("Failed to install default TLS provider");

    // Logging configuration
    tracing_subscriber::fmt::init();

    // Create a channel for the dummy gRPC requests
    let (dummy_grpc_sender, dummy_grpc_receiver) = mpsc::channel::<DummyRequest>(32);

    // Initialise the orchestrator with the dummy gRPC receiver
    let orchestrator = Orchestrator::new(dummy_grpc_receiver);

    // Spawn the orchestrator's main loop
    tokio::spawn(async move {
        orchestrator.run().await;
    });

    // Allow the orchestrator time to initialise
    time::sleep(time::Duration::from_secs(1)).await;

    // Send the dummy subscribe request (first websocket actor)
    dummy_grpc_sender
        .send(DummyRequest::Subscribe {
            internal_symbol: "Deribit.InvFut.BTC.USD".to_string(),
            exchange: "Deribit".to_string(),
            exchange_symbol: "BTC-PERPETUAL".to_string(),
            requested_feed: RequestedFeed::OrderBook,
        })
        .await
        .expect("Failed to send first subscribe request");

    // Wait to observe heartbeats from the first actor
    time::sleep(Duration::from_secs(5)).await;

    // Send another dummy subscribe request.
    dummy_grpc_sender
        .send(DummyRequest::Subscribe {
            internal_symbol: "Deribit.InvFut.ETH.USD".to_string(),
            exchange: "Deribit".to_string(),
            exchange_symbol: "ETH-PERPETUAL".to_string(),
            requested_feed: RequestedFeed::OrderBook,
        })
        .await
        .expect("Failed to send second subscribe request");

    time::sleep(Duration::from_secs(5)).await;

    // Send a dummy unsubscribe request for the first symbol
    dummy_grpc_sender
        .send(DummyRequest::Unsubscribe {
            internal_symbol: "Deribit.InvFut.BTC.USD".to_string(),
            exchange: "Deribit".to_string(),
            exchange_symbol: "BTC-PERPETUAL".to_string(),
            requested_feed: RequestedFeed::OrderBook,
        })
        .await
        .expect("Failed to send first subscribe request");

    time::sleep(Duration::from_secs(5)).await;

    // Send a dummy unsubscribe request for the second symbol
    dummy_grpc_sender
        .send(DummyRequest::Unsubscribe {
            internal_symbol: "Deribit.InvFut.ETH.USD".to_string(),
            exchange: "Deribit".to_string(),
            exchange_symbol: "ETH-PERPETUAL".to_string(),
            requested_feed: RequestedFeed::OrderBook,
        })
        .await
        .expect("Failed to send second unsubscribe request");

    // Wait to observe heartbeats from the first actor
    time::sleep(Duration::from_secs(5)).await;

    info!("Main function is exiting.");
}
