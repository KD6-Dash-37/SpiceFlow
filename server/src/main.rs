//! # SpiceFlow - Server - A Market Data Server

mod actors;
use actors::bc::BroadcastActor;
use actors::ob::OrderBookActor;
use actors::stream_config::StreamConfig;
use actors::ws::WebSocketActor;
use dotenv::dotenv;
use tokio::sync::mpsc;

#[tokio::main]
async fn main() {
    // Load env
    dotenv().ok();

    // Initialise the logger
    env_logger::init();

    // https://github.com/snapview/tokio-tungstenite/issues/353
    rustls::crypto::aws_lc_rs::default_provider()
        .install_default()
        .expect("Failed to install default TLS provider");

    // Create a communication channel between OrderBookActor and WebsocketActor
    let (ws_command_sender, ws_command_receiver) = mpsc::channel(10);

    // Create a communication channel for messages from OrderBookActor to BroadcastActor
    let (broadcast, receiver) = mpsc::channel(10); // FIXME

    // Create ZeroMQ context
    // Create ZeroMQ context and socket
    let zmq_context = zmq::Context::new();
    let zmq_socket = zmq_context
        .socket(zmq::PUB)
        .expect("Failed to create ZeroMQ socket");
    zmq_socket
        .bind("tcp://*:5555")
        .expect("Failed to bind ZeroMQ socket");

    // Initialise config, this will be replaced and generated by StreamManager in later iters
    let config = StreamConfig::current();

    // Initialise the BroadcastActor which has a channel to receive messages from the OrderBookActor
    let mut broadcast_actor = BroadcastActor::new(receiver, zmq_socket);
    // Initialise the OrderBookActor and its receiver
    let (mut order_book_actor, order_book_sender) =
        OrderBookActor::new("OrderBookActor", config, broadcast, ws_command_sender);

    // Initialise the WebSocketActor, passing the sender to the OrderBookActor
    let mut ws_actor =
        WebSocketActor::new("WebSocketActor", order_book_sender, ws_command_receiver);

    // Run the actors concurrently
    tokio::join!(
        broadcast_actor.run(),
        order_book_actor.run(),
        ws_actor.run(),
    );
}
