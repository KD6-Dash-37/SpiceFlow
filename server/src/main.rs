//! # SpiceFlow - Server - A Market Data Server

use dotenv::dotenv;
use server::actors::bc::BroadcastActor;
use server::actors::ob::OrderBookActor;
use server::actors::router::{DeribitMessageRouter, ParsedMessage};
use server::actors::stream_config::StreamConfig;
use server::actors::orch::Orchestrator;
use tokio::sync::mpsc;

const CHANNEL_BUFFER_SIZE: usize = 10;

#[tokio::main]
async fn main() {
    // Load env
    dotenv().ok();

    // Initialise the logger
    env_logger::Builder::from_env(env_logger::Env::default().default_filter_or("info"))
        .format(|buf, record| {
            use std::io::Write;
            writeln!(
                buf,
                "{} [{}:{}] {} - {}",
                chrono::Local::now().format("%Y-%m-%d %H:%M:%S"),
                record.file().unwrap_or("unknown"),
                record.line().unwrap_or(0),
                record.level(),
                record.args()
            )
        })
        .init();

    // https://github.com/snapview/tokio-tungstenite/issues/353
    rustls::crypto::aws_lc_rs::default_provider()
        .install_default()
        .expect("Failed to install default TLS provider");

    // Create ZeroMQ context
    // Create ZeroMQ context and socket
    let zmq_context = zmq::Context::new();
    let zmq_socket = zmq_context
        .socket(zmq::PUB)
        .expect("Failed to create ZeroMQ socket");
    zmq_socket
        .bind("tcp://*:5555")
        .expect("Failed to bind ZeroMQ socket");

    // Prototype Orchestrator
    let (tx, rx) = mpsc::channel(32);
    let mut orchestrator = Orchestrator::new(rx);

    // Create channels
    // WS to Router
    let (ws_router_sender, ws_router_receiver) = mpsc::channel::<String>(CHANNEL_BUFFER_SIZE);
    // OrderBookActor to WebsocketActor to send resubscribes
    // TODO responsibility to be shared between Router and OB in future release
    let (ws_command_sender, ws_command_receiver) = mpsc::channel(CHANNEL_BUFFER_SIZE);
    // OrderBookActor to BroadcastActor
    let (broadcast, receiver) = mpsc::channel(CHANNEL_BUFFER_SIZE);
    // Router to OrderBookActor
    let (parsed_data_sender, parsed_data_receiver) =
        mpsc::channel::<ParsedMessage>(CHANNEL_BUFFER_SIZE);

    // Initialise config, this will be replaced and generated by StreamManager in later iters
    let config = StreamConfig::current();

    // Create Actors
    let mut broadcast_actor = BroadcastActor::new(receiver, zmq_socket);
    let mut order_book_actor = OrderBookActor::new(
        "OrderBookActor",
        &config,
        parsed_data_receiver,
        broadcast,
        ws_command_sender,
    );
    let mut router_actor = DeribitMessageRouter::new(ws_router_receiver, parsed_data_sender);

    orchestrator.spawn_websocket_actor(ws_router_sender, ws_command_receiver);

    // Run the actors concurrently
    tokio::join!(
        broadcast_actor.run(),
        order_book_actor.run(),
        router_actor.run()
    );
}
